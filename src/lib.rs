use std::path::Path;

use serde::Deserialize;

include!(concat!(env!("OUT_DIR"), "/proto.rs"));

pub use api_client::ApiClient;

/// gRPC client configuration for Velociraptor
#[allow(dead_code)]
#[derive(Deserialize)]
pub struct Config {
    ca_certificate: String,
    client_cert: String,
    client_private_key: String,
    api_connection_string: String,
    name: String,
}

use tonic::transport::{Certificate, ClientTlsConfig, Endpoint, Identity, Uri};

impl Config {
    /// Construct client configuration from YAML file as generated by
    /// `velociraptor config api_client --name $NAME $OUT_FILE`
    pub fn from_yaml_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let cc = serde_yaml::from_reader(std::fs::File::open(path)?)?;
        Ok(cc)
    }

    fn tls_config(&self) -> ClientTlsConfig {
        let ca = Certificate::from_pem(self.ca_certificate.clone());
        let id = Identity::from_pem(self.client_cert.clone(), self.client_private_key.clone());
        ClientTlsConfig::new()
            .domain_name("VelociraptorServer")
            .ca_certificate(ca)
            .identity(id)
    }

    /// Construct an Velociraptor gPRC client endpoint from Config
    pub fn endpoint(&self) -> Result<Endpoint, Box<dyn std::error::Error>> {
        let uri = Uri::builder()
            .scheme("https")
            .authority(self.api_connection_string.as_str())
            .path_and_query("/")
            .build()?;
        let endpoint = Endpoint::from(uri).tls_config(self.tls_config())?;
        Ok(endpoint)
    }
}
